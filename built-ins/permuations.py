"""
Detailed explanation of the Lexicographic approach for generating permutations
This is the algorithm used internally by itertools.permutations()
"""


def permutations_lexicographic_explained(iterable, r=None):
    """
    Lexicographic permutation generator with detailed explanations
    """
    pool = tuple(iterable)
    n = len(pool)
    r = n if r is None else r

    if r > n:
        return

    print(f"=== Generating permutations of {pool} with r={r} ===")
    print(f"Pool size (n): {n}")
    print(f"Permutation length (r): {r}")

    # Step 1: Initialize indices and cycles
    indices = list(range(n))  # [0, 1, 2, ..., n-1]
    cycles = list(range(n, n - r, -1))  # [n, n-1, n-2, ..., n-r+1]

    print("\nInitial state:")
    print(f"indices: {indices}")
    print(f"cycles:  {cycles}")
    print(f"cycles meaning: {[f'pos{i}â†’{cycles[i]}' for i in range(r)]}")

    # Step 2: Yield first permutation
    first_perm = tuple(pool[i] for i in indices[:r])
    print(f"\nFirst permutation: {first_perm}")
    yield first_perm

    step_count = 1

    # Step 3: Generate remaining permutations
    while True:
        print(f"\n--- Step {step_count} ---")
        print(f"Current indices: {indices}")
        print(f"Current cycles:  {cycles}")

        # Try to advance from rightmost position
        found_swap = False

        for i in reversed(range(r)):
            print(f"\nTrying position {i} (cycles[{i}] = {cycles[i]})")

            cycles[i] -= 1
            print(f"Decremented cycles[{i}] to {cycles[i]}")

            if cycles[i] == 0:
                print(f"cycles[{i}] became 0 - need to cycle!")

                # Cycle completed - move current element to end and reset
                element_to_move = indices[i]
                indices[i:] = indices[i + 1:] + [element_to_move]
                cycles[i] = n - i

                print(f"After cycling: indices = {indices}")
                print(f"Reset cycles[{i}] = {cycles[i]}")

            else:
                print(f"cycles[{i}] = {cycles[i]} > 0 - can swap!")

                # Swap with the element at position n-cycles[i]
                j = cycles[i]
                swap_pos = len(indices) - j  # This is n - cycles[i]

                print(f"Swapping indices[{i}] with indices[{swap_pos}]")
                print(f"Before swap: {indices}")

                indices[i], indices[swap_pos] = indices[swap_pos], indices[i]

                print(f"After swap:  {indices}")

                # Generate new permutation
                new_perm = tuple(pool[i] for i in indices[:r])
                print(f"New permutation: {new_perm}")

                yield new_perm
                found_swap = True
                break

        if not found_swap:
            print("\nNo more swaps possible - all permutations generated!")
            return

        step_count += 1


def visualize_cycles_concept():
    """
    Visualize what the cycles array represents
    """
    print("=== Understanding the Cycles Array ===\n")

    print("For permutations of [A, B, C, D] with r=3:")
    print("Initial: indices = [0, 1, 2, 3], cycles = [4, 3, 2]")
    print()

    print("What cycles[i] means:")
    print("- cycles[0] = 4: Position 0 can use any of 4 elements (A,B,C,D)")
    print("- cycles[1] = 3: Position 1 can use any of 3 remaining elements")
    print("- cycles[2] = 2: Position 2 can use any of 2 remaining elements")
    print()

    print("How cycling works:")
    print("When cycles[i] becomes 0:")
    print("1. We've used all possible elements for position i")
    print("2. Move current element at position i to the end")
    print("3. Shift all elements after position i one place left")
    print("4. Reset cycles[i] = n - i")
    print()

    print("Example of cycling at position 1:")
    print("Before: indices = [0, 2, 1, 3] (representing A, C, B, D)")
    print(
        "After:  indices = [0, 1, 3, 2] \
            (moved element 2 to end, shifted others)"
    )


def step_by_step_example():
    """
    Show a complete step-by-step example
    """
    print("=== Complete Step-by-Step Example ===")
    print("Generating all permutations of 'ABC' with r=2\n")

    # Show the process
    result = list(permutations_lexicographic_explained("ABC"))

    print(f"\nFinal result: {result}")
    print(f"Total permutations: {len(result)}")


def compare_with_manual_calculation():
    """
    Compare with manual enumeration to verify correctness
    """
    print("\n=== Verification ===")
    print("Manual enumeration of permutations of 'ABC' with r=2:")
    manual = ["AB", "AC", "BA", "BC", "CA", "CB"]
    print(manual)

    print("\nGenerated by our algorithm:")
    generated = [
        "".join(p) for p in permutations_lexicographic_explained("ABC")
    ]
    print(generated)

    print(f"\nMatch: {manual == generated}")


# Main execution
if __name__ == "__main__":
    # visualize_cycles_concept()
    print("\n" + "=" * 60 + "\n")
    step_by_step_example()
    compare_with_manual_calculation()

    print("\n" + "=" * 60)
    print("KEY INSIGHTS:")
    print("1. The algorithm works right-to-left through positions")
    print("2. cycles[i] tracks remaining swaps available for position i")
    print("3. When cycles[i] = 0, we cycle (rotate) elements and reset")
    print("4. When cycles[i] > 0, we swap and generate next permutation")
    print("5. This generates permutations in lexicographic order")
    print("6. No recursion needed - uses iterative state machine")
