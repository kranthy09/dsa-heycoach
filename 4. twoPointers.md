## Searching, Sorting Methods:<br>Two pointers & Sliding window

**Two Pointers**: <br>

- Two variables, point to indices of an array and keeps moving while analysing the values at the two pointers

**Sliding Window**: <br>

- A problem solving technique, which uses two pointers to consider all elements between those two pointers in logic

Suppose in an array, arr = [2, 1, 5, 4, 3, 6], intialize two pointers i,j with 0,1 respectively.
While iterating through the array, i,j will move.

<br>
In case of sliding window, i,j are 0,2 respectively, while iterating logic considers all three elements, such that i, j will move so the window of the array moves.

### Question

<br>
<b>Two sum problem</b>
<br>

Given an array and a target, find if there exists a pair that sums up to target.
<br>

```
arr = [0, 1, 3, 6, 9, 8, 7], target = 11
```

<b>Brute Force</b>
<br>

```
for (i=0 to n-1)<br>
{
    for (j=i+1 to n-1)
    {
        if arr[i] + arr[j] == target:
            print(i,j)
    }
}
```

<b>Time Complexity</b> : O(n^2)

#

<b>Binary Search Approach</b>:

Suppose if the array is sorted and the pair in the array X, Y such that X + Y = target. Now fix one element in the pair and find the complementary element from element left to start.

The problem deduces to find the complementary element (target - X), and the array is sorted then binary search technique can be applied to reduce the iterations(time complexity). <br>

For each element in the array, search for the target in between [0,i-1].

```
for (i=0 to n-1)
{
    l = 0
    r = i-1
    while l <= r:
        mid = l + (r-l)//2
        if target - arr[i] == arr[mid]:
            return mid, i
        elif target - arr[i] > arr[mid]:
            r = mid - 1
        else:
            l = mid + 1
    return -1 # no pair found
}
```

<b>Time Complexity</b> : O(nlogn) + O(logn)

#

<b>Two Pointers</b>
